# 📘 Backend Nómina

## 🏗️ Arquitectura y Estructura del Proyecto

Este proyecto está basado en los principios de **DDD (Domain-Driven Design)**, **arquitectura hexagonal** y **principios SOLID**, separando claramente las responsabilidades entre dominio, aplicación, infraestructura y entrada/salida.

```
app/
├── domain/                         # Modelo de dominio puro
│   ├── models/                    # Entidades del dominio (Empresa, Centro, etc.)
│   └── repositories/             # Interfaces abstractas de repositorios
├── application/                   # Casos de uso (servicios de aplicación)
│   └── use_cases/
│       └── <entidad>/            # Casos de uso por entidad (crear, listar, etc.)
├── infrastructure/
│   ├── db/                       # Configuración de la BBDD y modelos SQLAlchemy
│   │   ├── session.py           # Conexion con SQLAlchemy
│   │   └── models/
│   ├── repositories/            # Implementaciones concretas de repositorios
│   └── interfaces/
│       └── api/                 # Rutas de FastAPI
scripts/                          # Scripts para poblar y testear
```

## 🧠 Entidades implementadas hasta ahora

- `Organización`
- `Empresa`
- `Centro`

Cada una con su CRUD completo: modelo, repositorio abstracto, casos de uso, infraestructura y endpoints.

## ✍️ Cómo crear una nueva entidad (CRUD completo)

1. **Modelo de dominio**: `domain/models/<entidad>.py`
2. **Interfaz de repositorio**: `domain/repositories/<entidad>_repository.py`
3. **Casos de uso**: `application/use_cases/<entidad>/crear.py`, `listar.py`, etc.
4. **Modelo SQLAlchemy**: `infrastructure/db/models/<entidad>_model.py`
5. **Repositorio MySQL**: `infrastructure/repositories/<entidad>_repository_mysql.py`
6. **Rutas FastAPI**: `infrastructure/interfaces/api/<entidad>_routes.py`
7. **Registrar el router** en `main.py`

## 🔄 Flujo de información

1. 🧑‍💻 El cliente envía una petición HTTP → `FastAPI` la recibe en `/entidad`  
2. 🔄 Se llama al caso de uso correspondiente (por ejemplo, `CrearEmpresa`)  
3. 💼 El caso de uso utiliza un repositorio que implementa la interfaz definida en dominio  
4. 🛢️ La implementación del repositorio accede a la BBDD vía SQLAlchemy  
5. 📤 El caso de uso devuelve los datos transformados o una confirmación  
6. 🌐 El endpoint devuelve la respuesta HTTP al cliente

## 🚀 Comandos Docker básicos

### Construir y levantar contenedores
```bash
docker-compose up --build
```

### Acceder al contenedor backend
```bash
docker exec -it backend_nomina bash
```

### Poblar base de datos con datos dummy
```bash
docker exec -it backend_nomina python scripts/poblar_tablas.py
```

### Probar endpoints con script de pruebas
```bash
docker exec -it backend_nomina python scripts/test_endpoints.py
```

### Reconstruir (si modificas Dockerfile o requirements.txt)
```bash
docker-compose build --no-cache
```

### VER LOGS
```bash
docker compose logs -f
```



## ✅ Buenas prácticas

- Nunca contamines el dominio con SQLAlchemy, FastAPI o detalles técnicos.
- Cada capa tiene su responsabilidad: **modelo limpio**, **servicio orquestador**, **infraestructura concreta**.
- Añade validaciones de negocio en los **casos de uso o modelo de dominio**, según corresponda.

## 🔐 Seguridad y Autenticación con JWT

Este backend implementa autenticación segura basada en **OAuth2 PasswordBearer + JWT con scopes**, completamente integrada respetando la arquitectura hexagonal y principios DDD/SOLID.

### 🧱 Componentes

- **Entidad `ClienteApi`**: Representa a los clientes autorizados a consumir la API.
- **Casos de uso**:
  - `crear_cliente.py`: Registro de nuevos clientes.
  - `generar_jwt.py`: Autenticación y emisión de JWT.
- **Infraestructura**:
  - `security/jwt_utils.py`: Creación y validación de JWT.
  - `security/deps.py`: Middleware y validación de permisos vía scopes.
  - `.env`: Claves secretas y configuración.
  - `config.py`: Acceso centralizado a variables del entorno.

---

### 🛠️ Cómo Registrar un Cliente (usuario API)

1. **POST** `/auth/registro`
   - Cuerpo (JSON):
     ```json
     {
       "username": "cliente001",
       "password": "supersegura"
     }
     ```
   - Esto crea un nuevo cliente en la base de datos.

---

### 🔑 Cómo Obtener un Token

1. **POST** `/auth/token`
   - Cuerpo (JSON):
     ```json
     {
       "username": "cliente001",
       "password": "supersegura"
     }
     ```
   - Devuelve un token JWT con scopes predefinidos (`read`, `write`).

---

### 📡 Cómo Usar el JWT para Acceder a la API

1. Incluir en cada request el token en la cabecera:
   ```http
   Authorization: Bearer <token_recibido>
   ```

2. Las rutas están protegidas con scopes. Ejemplo:
   ```python
   @router.get("/empresas", dependencies=[Security(get_current_user, scopes=["read"])])
   def listar_empresas():
       ...
   ```

---

### 📘 Consideraciones para Desarrolladores

- Los **secretos y parámetros del JWT** (`SECRET_KEY`, `ALGORITHM`, `EXPIRATION`) están en `.env` y accedidos mediante `config.py`.
- La validación de token y permisos está desacoplada en `security/deps.py`.
- JWT incluye un array de `scopes` que pueden ampliarse según el perfil del cliente.
- Para validar un cliente:
  - Se verifica existencia en la base de datos.
  - Se comprueba su hash de contraseña.
  - Se genera un JWT firmado que incluye sus permisos.

