# ğŸ“˜ Backend NÃ³mina

## ğŸ—ï¸ Arquitectura y Estructura del Proyecto

Este proyecto estÃ¡ basado en los principios de **DDD (Domain-Driven Design)**, **arquitectura hexagonal** y **principios SOLID**, separando claramente las responsabilidades entre dominio, aplicaciÃ³n, infraestructura y entrada/salida.

```
app/
â”œâ”€â”€ domain/                         # Modelo de dominio puro
â”‚   â”œâ”€â”€ models/                    # Entidades del dominio (Empresa, Centro, etc.)
â”‚   â””â”€â”€ repositories/             # Interfaces abstractas de repositorios
â”œâ”€â”€ application/                   # Casos de uso (servicios de aplicaciÃ³n)
â”‚   â””â”€â”€ use_cases/
â”‚       â””â”€â”€ <entidad>/            # Casos de uso por entidad (crear, listar, etc.)
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ db/                       # ConfiguraciÃ³n de la BBDD y modelos SQLAlchemy
â”‚   â”‚   â”œâ”€â”€ session.py           # Conexion con SQLAlchemy
â”‚   â”‚   â””â”€â”€ models/
â”‚   â”œâ”€â”€ repositories/            # Implementaciones concretas de repositorios
â”‚   â””â”€â”€ interfaces/
â”‚       â””â”€â”€ api/                 # Rutas de FastAPI
scripts/                          # Scripts para poblar y testear
```

## ğŸ§  Entidades implementadas hasta ahora

- `OrganizaciÃ³n`
- `Empresa`
- `Centro`

Cada una con su CRUD completo: modelo, repositorio abstracto, casos de uso, infraestructura y endpoints.

## âœï¸ CÃ³mo crear una nueva entidad (CRUD completo)

1. **Modelo de dominio**: `domain/models/<entidad>.py`
2. **Interfaz de repositorio**: `domain/repositories/<entidad>_repository.py`
3. **Casos de uso**: `application/use_cases/<entidad>/crear.py`, `listar.py`, etc.
4. **Modelo SQLAlchemy**: `infrastructure/db/models/<entidad>_model.py`
5. **Repositorio MySQL**: `infrastructure/repositories/<entidad>_repository_mysql.py`
6. **Rutas FastAPI**: `infrastructure/interfaces/api/<entidad>_routes.py`
7. **Registrar el router** en `main.py`

## ğŸ”„ Flujo de informaciÃ³n

1. ğŸ§‘â€ğŸ’» El cliente envÃ­a una peticiÃ³n HTTP â†’ `FastAPI` la recibe en `/entidad`  
2. ğŸ”„ Se llama al caso de uso correspondiente (por ejemplo, `CrearEmpresa`)  
3. ğŸ’¼ El caso de uso utiliza un repositorio que implementa la interfaz definida en dominio  
4. ğŸ›¢ï¸ La implementaciÃ³n del repositorio accede a la BBDD vÃ­a SQLAlchemy  
5. ğŸ“¤ El caso de uso devuelve los datos transformados o una confirmaciÃ³n  
6. ğŸŒ El endpoint devuelve la respuesta HTTP al cliente

## ğŸš€ Comandos Docker bÃ¡sicos

### Construir y levantar contenedores
```bash
docker-compose up --build
```

### Acceder al contenedor backend
```bash
docker exec -it backend_nomina bash
```

### Poblar base de datos con datos dummy
```bash
docker exec -it backend_nomina python scripts/poblar_tablas.py
```

### Probar endpoints con script de pruebas
```bash
docker exec -it backend_nomina python scripts/test_endpoints.py
```

### Reconstruir (si modificas Dockerfile o requirements.txt)
```bash
docker-compose build --no-cache
```

### VER LOGS
```bash
docker compose logs -f
```



## âœ… Buenas prÃ¡cticas

- Nunca contamines el dominio con SQLAlchemy, FastAPI o detalles tÃ©cnicos.
- Cada capa tiene su responsabilidad: **modelo limpio**, **servicio orquestador**, **infraestructura concreta**.
- AÃ±ade validaciones de negocio en los **casos de uso o modelo de dominio**, segÃºn corresponda.


# ğŸ” Seguridad y AutenticaciÃ³n con JWT

Este backend implementa un sistema de autenticaciÃ³n robusto basado en **OAuth2 Password Flow + JWT con scopes**, totalmente integrado con FastAPI y compatible con Swagger UI.

---

## ğŸ§± Â¿CÃ³mo funciona?

Se utiliza `OAuth2PasswordBearer` como esquema de autenticaciÃ³n y los endpoints estÃ¡n protegidos mediante:

```python
user = Security(get_current_user, scopes=["read"])
```

Esto obliga a:
- âœ… Enviar un token JWT vÃ¡lido con cada peticiÃ³n.
- âœ… Que el token contenga los `scopes` necesarios para acceder al recurso.

Los tokens son creados en `jwt_utiles.py`, verificados en `deps.py`, y consumidos mediante `Security(...)`.

---

## ğŸ› ï¸ Ciclo completo de autenticaciÃ³n

### 1. Registrar el usuario `admin`

Este usuario puede registrar otros clientes API:

```http
POST /auth/registro
Content-Type: application/json

{
  "username": "admin",
  "password": "123456"
}
```

---

### 2. Login del `admin` y obtenciÃ³n de token

```http
POST /auth/token
Content-Type: application/x-www-form-urlencoded

username=admin
password=123456
```

Respuesta esperada:

```json
{
  "access_token": "eyJhbGciOi...",
  "token_type": "bearer"
}
```

---

### 3. Registro de nuevos clientes (requiere token de `admin`)

```http
POST /auth/registro
Authorization: Bearer <TOKEN_ADMIN>
Content-Type: application/json

{
  "username": "cliente001",
  "password": "pass123"
}
```

---

### 4. Login del cliente y obtenciÃ³n de su token

```http
POST /auth/token
Content-Type: application/x-www-form-urlencoded

username=cliente001
password=pass123
```

---

### 5. Acceso a endpoints protegidos

Los clientes deben incluir el token JWT en cada peticiÃ³n protegida:

```http
Authorization: Bearer <access_token>
```

O bien usar el botÃ³n "Authorize" en Swagger.

---

## ğŸ” Scopes disponibles

| Scope   | DescripciÃ³n                          |
|---------|--------------------------------------|
| `read`  | Acceso de lectura a recursos         |
| `write` | CreaciÃ³n y modificaciÃ³n de datos     |
| `admin` | GestiÃ³n de usuarios y administraciÃ³n |

---

## âœ… CÃ³mo proteger un endpoint

```python
@router.get("/empresas")
def listar(user = Security(get_current_user, scopes=["read"])):
    ...
```

Esto hace que el endpoint requiera un token vÃ¡lido y el scope `"read"`.

---

## âŒ CÃ³mo desproteger un endpoint

```python
# Antes
def listar(user = Security(get_current_user, scopes=["read"])):
    ...

# DespuÃ©s (sin seguridad)
def listar():
    ...
```

Esto hace que el endpoint sea pÃºblico. Ãšsalo con cuidado.

---

## ğŸ“š Swagger UI y el botÃ³n "Authorize"

1. Pulsa "Authorize" en Swagger.
2. Introduce `username`, `password` y selecciona los scopes.
3. Swagger obtiene el token desde `/auth/token`.
4. El token se usarÃ¡ automÃ¡ticamente en todas las peticiones protegidas.

---

## ğŸ“¦ Archivos clave

- `auth_routes.py`: login y registro de clientes
- `jwt_utiles.py`: generaciÃ³n y verificaciÃ³n de tokens
- `deps.py`: validaciÃ³n de token y control de scopes
- `config.py`: configuraciÃ³n del JWT (clave secreta, algoritmo, expiraciÃ³n)
